package net.limbomedia.dns.dns;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Socket;
import java.util.HashMap;
import net.limbomedia.dns.ZoneProvider;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.xbill.DNS.CNAMERecord;
import org.xbill.DNS.DClass;
import org.xbill.DNS.DNAMERecord;
import org.xbill.DNS.ExtendedFlags;
import org.xbill.DNS.Flags;
import org.xbill.DNS.Header;
import org.xbill.DNS.Message;
import org.xbill.DNS.Name;
import org.xbill.DNS.NameTooLongException;
import org.xbill.DNS.OPTRecord;
import org.xbill.DNS.Opcode;
import org.xbill.DNS.RRset;
import org.xbill.DNS.Rcode;
import org.xbill.DNS.Record;
import org.xbill.DNS.Section;
import org.xbill.DNS.SetResponse;
import org.xbill.DNS.TSIG;
import org.xbill.DNS.TSIGRecord;
import org.xbill.DNS.Type;
import org.xbill.DNS.Zone;

/**
 * Based on EagleDNS copyright Robert "Unlogic" Olofsson (unlogic@unlogic.se)
 * Based on the jnamed class from the dnsjava project (http://www.dnsjava.org/) copyright (c) 1999-2004 Brian Wellington (bwelling@xbill.org)
 *
 * @author Robert "Unlogic" Olofsson
 * @author Michael Neale, Red Hat (JBoss division)
 */
public class ResolverImpl implements Resolver {

    private static final Logger L = LogManager.getLogger(ResolverImpl.class);

    static final int FLAG_DNSSECOK = 1;
    static final int FLAG_SIGONLY = 2;

    private final HashMap<Name, TSIG> TSIGs = new HashMap<Name, TSIG>();

    private ZoneProvider zoneProvider;

    public ResolverImpl(ZoneProvider zoneProvider) {
        this.zoneProvider = zoneProvider;

        if (zoneProvider == null) {
            L.error("No zone providers found or started, aborting startup!");
            return;
        }
    }

    @SuppressWarnings("unused")
    private void addTSIG(String algstr, String namestr, String key) throws IOException {
        Name name = Name.fromString(namestr, Name.root);
        TSIGs.put(name, new TSIG(algstr, namestr, key));
    }

    private Zone findBestZone(Name name) {
        Zone foundzone = zoneProvider.zoneGet(name);

        if (foundzone != null) {
            return foundzone;
        }

        int labels = name.labels();

        for (int i = 1; i < labels; i++) {

            Name tname = new Name(name, i);
            foundzone = zoneProvider.zoneGet(tname);

            if (foundzone != null) {
                return foundzone;
            }
        }

        return null;
    }

    private RRset findExactMatch(Name name, int type, int dclass, boolean glue) {
        Zone zone = findBestZone(name);

        if (zone != null) {
            return zone.findExactMatch(name, type);
        }

        return null;
    }

    private void addRRset(Name name, Message response, RRset rrset, int section, int flags) {
        for (int s = 1; s <= section; s++) {
            if (response.findRRset(name, rrset.getType(), s)) {
                return;
            }
        }
        if ((flags & FLAG_SIGONLY) == 0) {
            rrset.rrs().forEach(r -> {
                if (r.getName().isWild() && !name.isWild()) {
                    r = r.withName(name);
                }
                response.addRecord(r, section);
            });
        }
        if ((flags & (FLAG_SIGONLY | FLAG_DNSSECOK)) != 0) {
            rrset.sigs().forEach(r -> {
                if (r.getName().isWild() && !name.isWild()) {
                    response.addRecord(r.withName(name), section);
                } else {
                    response.addRecord(r, section);
                }
            });
        }
    }

    private final void addSOA(Message response, Zone zone) {
        response.addRecord(zone.getSOA(), Section.AUTHORITY);
    }

    private final void addNS(Message response, Zone zone, int flags) {
        RRset nsRecords = zone.getNS();
        addRRset(nsRecords.getName(), response, nsRecords, Section.AUTHORITY, flags);
    }

    private void addGlue(Message response, Name name, int flags) {
        RRset a = findExactMatch(name, Type.A, DClass.IN, true);
        if (a == null) {
            return;
        }
        addRRset(name, response, a, Section.ADDITIONAL, flags);
    }

    private void addAdditional2(Message response, int section, int flags) {
        response.getSection(section).forEach(r -> {
            Name glueName = r.getAdditionalName();
            if (glueName != null) {
                addGlue(response, glueName, flags);
            }
        });
    }

    private final void addAdditional(Message response, int flags) {
        addAdditional2(response, Section.ANSWER, flags);
        addAdditional2(response, Section.AUTHORITY, flags);
    }

    private byte addAnswer(Message response, Name name, int type, int dclass, int iterations, int flags) {
        SetResponse sr;
        byte rcode = Rcode.NOERROR;

        if (iterations > 6) {
            return Rcode.NOERROR;
        }

        if (type == Type.SIG || type == Type.RRSIG) {
            type = Type.ANY;
            flags |= FLAG_SIGONLY;
        }

        Zone zone = findBestZone(name);
        if (zone != null) {
            sr = zone.findRecords(name, type);

            if (sr.isNXDOMAIN()) {
                response.getHeader().setRcode(Rcode.NXDOMAIN);
                if (zone != null) {
                    addSOA(response, zone);
                    if (iterations == 0) {
                        response.getHeader().setFlag(Flags.AA);
                    }
                }
                rcode = Rcode.NXDOMAIN;
            } else if (sr.isNXRRSET()) {
                if (zone != null) {
                    addSOA(response, zone);
                    if (iterations == 0) {
                        response.getHeader().setFlag(Flags.AA);
                    }
                }
            } else if (sr.isDelegation()) {
                RRset nsRecords = sr.getNS();
                addRRset(nsRecords.getName(), response, nsRecords, Section.AUTHORITY, flags);
            } else if (sr.isCNAME()) {
                CNAMERecord cname = sr.getCNAME();
                RRset rrset = new RRset(cname);
                addRRset(name, response, rrset, Section.ANSWER, flags);
                if (zone != null && iterations == 0) {
                    response.getHeader().setFlag(Flags.AA);
                }
                rcode = addAnswer(response, cname.getTarget(), type, dclass, iterations + 1, flags);
            } else if (sr.isDNAME()) {
                DNAMERecord dname = sr.getDNAME();
                RRset rrset = new RRset(dname);
                addRRset(name, response, rrset, Section.ANSWER, flags);
                Name newname;
                try {
                    newname = name.fromDNAME(dname);
                } catch (NameTooLongException e) {
                    return Rcode.YXDOMAIN;
                }
                rrset = new RRset(new CNAMERecord(name, dclass, 0, newname));
                addRRset(name, response, rrset, Section.ANSWER, flags);
                if (zone != null && iterations == 0) {
                    response.getHeader().setFlag(Flags.AA);
                }
                rcode = addAnswer(response, newname, type, dclass, iterations + 1, flags);
            } else if (sr.isSuccessful()) {
                for (RRset rrset : sr.answers()) {
                    addRRset(name, response, rrset, Section.ANSWER, flags);
                }
                if (zone != null) {
                    addNS(response, zone, flags);
                    if (iterations == 0) {
                        response.getHeader().setFlag(Flags.AA);
                    }
                }
            }
        }

        return rcode;
    }

    /*
     * Note: a null return value means that the caller doesn't need to do
     * anything.  Currently this only happens if this is an AXFR request over
     * TCP.
     */
    @Override
    public byte[] generateReply(Message query, byte[] in, int length, Socket socket) throws IOException {
        Header header;
        // boolean badversion;
        int maxLength;
        int flags = 0;

        header = query.getHeader();
        if (header.getFlag(Flags.QR)) {
            return null;
        }
        if (header.getRcode() != Rcode.NOERROR) {
            return errorMessage(query, Rcode.FORMERR);
        }
        if (header.getOpcode() != Opcode.QUERY) {
            return errorMessage(query, Rcode.NOTIMP);
        }

        Record queryRecord = query.getQuestion();

        TSIGRecord queryTSIG = query.getTSIG();
        TSIG tsig = null;
        if (queryTSIG != null) {
            tsig = TSIGs.get(queryTSIG.getName());
            if (tsig == null || tsig.verify(query, in, null) != Rcode.NOERROR) {
                return formerrMessage(in);
            }
        }

        OPTRecord queryOPT = query.getOPT();
        if (queryOPT != null && queryOPT.getVersion() > 0) {
            // badversion = true;
        }

        if (socket != null) {
            maxLength = 65535;
        } else if (queryOPT != null) {
            maxLength = Math.max(queryOPT.getPayloadSize(), 512);
        } else {
            maxLength = 512;
        }

        if (queryOPT != null && (queryOPT.getFlags() & ExtendedFlags.DO) != 0) {
            flags = FLAG_DNSSECOK;
        }

        Message response = new Message(query.getHeader().getID());
        response.getHeader().setFlag(Flags.QR);
        if (query.getHeader().getFlag(Flags.RD)) {
            response.getHeader().setFlag(Flags.RD);
        }
        response.addRecord(queryRecord, Section.QUESTION);

        Name name = queryRecord.getName();
        int type = queryRecord.getType();
        int dclass = queryRecord.getDClass();
        if (type == Type.AXFR && socket != null) {
            return errorMessage(query, Rcode.NOTIMP);
        }
        if (!Type.isRR(type) && type != Type.ANY) {
            return errorMessage(query, Rcode.NOTIMP);
        }

        byte rcode = addAnswer(response, name, type, dclass, 0, flags);
        if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) {
            return errorMessage(query, rcode);
        }

        addAdditional(response, flags);

        if (queryOPT != null) {
            int optflags = (flags == FLAG_DNSSECOK) ? ExtendedFlags.DO : 0;
            OPTRecord opt = new OPTRecord((short) 4096, rcode, (byte) 0, optflags);
            response.addRecord(opt, Section.ADDITIONAL);
        }

        response.setTSIG(tsig, Rcode.NOERROR, queryTSIG);
        return response.toWire(maxLength);
    }

    private byte[] buildErrorMessage(Header header, int rcode, Record question) {
        Message response = new Message();
        response.setHeader(header);
        for (int i = 0; i < 4; i++) {
            response.removeAllRecords(i);
        }
        if (rcode == Rcode.SERVFAIL) {
            response.addRecord(question, Section.QUESTION);
        }
        header.setRcode(rcode);
        return response.toWire();
    }

    @Override
    public byte[] formerrMessage(byte[] in) {
        Header header;
        try {
            header = new Header(in);
        } catch (IOException e) {
            return null;
        }
        return buildErrorMessage(header, Rcode.FORMERR, null);
    }

    private byte[] errorMessage(Message query, int rcode) {
        return buildErrorMessage(query.getHeader(), rcode, query.getQuestion());
    }

    protected void UDPClient(DatagramSocket socket, DatagramPacket inDataPacket) {}

    public static String toString(Record record) {

        if (record == null) {

            return null;
        }

        StringBuilder stringBuilder = new StringBuilder();

        stringBuilder.append(record.getName());

        stringBuilder.append(" ");

        stringBuilder.append(record.getTTL());

        stringBuilder.append(" ");

        stringBuilder.append(DClass.string(record.getDClass()));

        stringBuilder.append(" ");

        stringBuilder.append(Type.string(record.getType()));

        String rdata = record.rdataToString();

        if (!rdata.equals("")) {
            stringBuilder.append(" ");
            stringBuilder.append(rdata);
        }

        return stringBuilder.toString();
    }
}
